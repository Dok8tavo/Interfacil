//!zig-autodoc-guide: guides/conventions.md
//!zig-autodoc-guide: guides/glossary.md
//!zig-autodoc-section: tutorials
//!zig-autodoc-guide: guides/tutorials/interface-usage.md
//!zig-autodoc-guide: guides/tutorials/interface-writing.md

const std = @import("std");

pub const misc = @import("misc.zig");
pub const contracts = @import("contracts.zig");

const EnumLiteral = misc.EnumLiteral;

/// # Equivalent
/// This interface is useful when dealing with a function with two parameter of the same type that
/// happen to be an equivalency (i.e, reflexive, symmetric and transitive). It provides a few unit
/// tests, wraps the equivalency into a few ub checks, and provides a few additional functions.
///
/// By default this is the equivalency function is an equality function generated by `equalsFn`.
///
/// ## API
///
/// ```zig
/// allEq: fn (Self, []const Self) bool,
/// anyEq: fn (Self, []const Self) ?usize,
/// eq: fn (Self, Self) bool,
/// filteredAllEq: fn ([]const Self, []const Self, []Self) ![]Self,
/// filterAllEq: fn ([]const Self, []Self) []Self,
/// fielteredEq: fn (Self, []const Self, []Self) ![]Self,
/// filterEq: fn (Self, []Self) ![]Self,
/// equivalency_tests: struct {
///     reflexivity: fn ([]const Self) !void,
///     symmetry: fn ([]const Self) !void,
///     transitivity: fn ([]const Self) !void,
///
///     test "Equivalency is reflexive";
///     test "Equivalency is symmetric";
///     test "Equivalency is transitive";
///     test "Equivalency";
/// },
/// ```
///
/// ## Clauses
///
/// ```zig
/// eq: fn (Self, Self) bool = equalsFn(Self),
/// ub_checked: bool = true,
/// sample: []const Self = emptySlice(Self),
/// Self: type = Contractor,
/// ```
pub fn Equivalent(comptime Contractor: type, comptime clauses: anytype) type {
    return struct {
        const contract = contracts.Contract(Contractor, clauses);

        /// This function checks if all the items of the `slice` parameter are equivalent to the
        /// `self` parameter.
        pub fn allEq(
            self: Self,
            slice: []const Self,
        ) bool {
            return for (slice) |item| {
                if (!eq(self, item)) break false;
            } else true;
        }

        /// This function checks if there's at least one item of the `slice` parameter that's
        /// equivalent to the `self` parameter.
        pub fn anyEq(self: Self, slice: []const Self) ?usize {
            return for (slice, 0..) |item, i| {
                if (eq(self, item)) break i;
            } else null;
        }

        /// This function counts how many items of the `slice` parameter are equivalent to the
        /// `self` parameter.
        pub fn countEq(self: Self, slice: []const Self) usize {
            var count: usize = 0;
            for (slice) |item| {
                if (eq(self, item)) count += 1;
            }
            return count;
        }

        /// This function checks if the `self` parameter is equivalent to the `other` parameter.
        pub const eq: fn (self: Self, other: Self) bool =
            if (ub_checked) checkedEq else uncheckedEq;

        /// This function filter out all the elements of the `filtered` parameters that are
        /// equivalent to one item of the `filters` parameter.
        pub fn filterAllEq(filters: []const Self, filtered: []Self) []Self {
            return filteredAllEq(filters, filtered, filtered) catch unreachable;
        }

        /// This function filter out all the elements of the `filtered` parameters that are
        /// equivalent to the `self` parameter.
        pub fn filterEq(self: Self, filtered: []Self) []Self {
            return filteredEq(self, filtered, filtered) catch unreachable;
        }

        /// This function copy all the items of the `from` parameter that aren't equivalent to any
        /// item of the `filters` parameter into the `into` parameter.
        pub fn filteredAllEq(
            filters: []const Self,
            from: []const Self,
            into: []Self,
        ) error{OutOfMemory}![]Self {
            var index: usize = 0;
            return for (from) |item| {
                if (anyEq(item, filters)) |_| continue;
                if (index == into.len) break error.OutOfMemory;
                into[index] = item;
                index += 1;
            } else into[0..index];
        }

        /// This function copy all the items of the `from` parameter that aren't equivalent to the
        /// `self` parameter into the `into` parameter.
        pub fn filteredEq(
            self: Self,
            from: []const Self,
            into: []Self,
        ) error{OutOfMemory}![]Self {
            return try filteredAllEq(&[_]Self{self}, from, into);
        }

        /// This function checks if the `self` parameter isn't equivalent to the `other` parameter.
        pub fn no(self: Self, other: Self) bool {
            return !eq(self, other);
        }

        /// This function is either defined and declared by the user, or using `anyEq` by default.
        const uncheckedEq: fn (Self, Self) bool = contract.default(.eq, defaultEq);

        /// This boolean decides whether the program should check during runtime if equality
        /// actually is symmetric and reflexive. If not, it'll panic in debug mode, with a
        /// meaningful error message, in other modes it'll reach unreachable.
        ///
        /// As those checks have very bad complexity they're only done on calls for two elements,
        /// only `eq` and `no`. As there's no way to check for transitivity with two elements on
        /// a symmetric and reflexive relation, transitivity is not checked during runtime.
        const ub_checked: bool = contract.default(.ub_checked, true);

        const defaultEq: fn (Self, Self) bool = equalsFn(Self);

        /// This function wraps the `eq` function inside checks for symmetry and reflexivity. Those
        /// checks are only available in debug builds. They slow down debug builds but speed up
        /// unsafe builds.
        fn checkedEq(self: Self, other: Self) bool {
            const self_other = uncheckedEq(self, other);
            const other_self = uncheckedEq(other, self);
            const is_symmetric = self_other == other_self;

            misc.checkUB(!is_symmetric,
                \\The `{s}.eq` function isn't symmetric:
                \\    {any} {s} {any}
                \\    {any} {s} {any}
            , .{
                @typeName(Self),
                self,
                if (self_other) "===" else "!==",
                other,
                other,
                if (other_self) "===" else "!==",
                self,
            });

            inline for (.{ self, other }) |item| {
                const is_reflexive = uncheckedEq(item, item);
                misc.checkUB(!is_reflexive,
                    \\The `{s}.eq` function isn't reflexive:
                    \\   {any} !== {any}
                , .{
                    @typeName(Self),
                    item,
                    item,
                });
            }

            return self_other;
        }

        const Self: type = contract.default(.Self, Contractor);

        /// This namespace is a testing namespace for the `Equivalent` interface. It's intended to be
        /// used in tests, the functions inside have horrible complexity.
        pub const equivalency_tests = struct {
            /// This function fails when `∀x : x === x` is false in the given sample.
            ///
            /// It has a complexity of `O(n)`, with `n` being the length of  the sample, and
            /// assuming that the provided `eq` function is `O(1)`.
            pub fn reflexivity(sample: []const Self) ReflexivityError!void {
                if (!contract.hasClause(.eq)) return;
                for (sample) |x|
                    if (!testEq(x, x))
                        return ReflexivityError.EqualityIsNotReflexive;
            }

            /// This function fails when `∀x, y : (x === y) => (y === x)` is false in the given
            /// sample.
            ///
            /// It has a time complexity of `O(n^2)`, with `n` being the length of  the sample,
            /// and assuming that the provided `eq` function is `O(1)`.
            pub fn symmetry(sample: []const Self) SymmetryError!void {
                if (!contract.hasClause(.eq)) return;
                for (sample) |x| for (sample) |y|
                    if (testEq(x, y) and !testEq(y, x))
                        return SymmetryError.EqualityIsNotSymmetric;
            }

            /// This function fails when `∀x, y, z : ((x === y) & (y === z)) => (x === z)` is false
            /// in the given sample.
            ///
            /// It has a time complexity of `O(n^3)`, with `n` being the length of  the sample,
            /// and assuming that the provided `eq` function is `O(1)`.
            pub fn transitivity(sample: []const Self) TransitivityError!void {
                if (!contract.hasClause(.eq)) return;
                for (sample) |x| for (sample) |y| for (sample) |z|
                    //    ∀x, y, z : ((x === y) & (y === z)) => (x === z)
                    // => ∀x, y, z : !((x === y) & (y === z)) | (x === z)
                    // => ∀x, y, z : (!(x === y) | !(y === z)) | (x === z)
                    // => ∀x, y, z : (x !== y) | (y !== z) | (x === z)
                    if (!testEq(x, y) or !testEq(y, z) or testEq(x, z))
                        return TransitivityError.EqualityIsNotTransitive;
            }

            pub const ReflexivityError = error{EqualityIsNotReflexive};
            pub const SymmetryError = error{EqualityIsNotSymmetric};
            pub const TransitivityError = error{EqualityIsNotTransitive};

            /// This equivalent function should be used for tests. It must be unchecked, otherwise
            /// there might be infinite recursive call on checking functions.
            const testEq: fn (Self, Self) bool = uncheckedEq;

            /// This slice is a sample used for generating tests. It can be useful when certain
            /// combinations of instances of `Contractor`
            const testing_sample: []const Self = contract.default(.sample, misc.emptySlice(Self));

            test "Equivalency is reflexive" {
                try reflexivity(testing_sample);
            }

            test "Equivalency is symmetric" {
                try symmetry(testing_sample);
            }

            test "Equivalency is transitive" {
                try transitivity(testing_sample);
            }

            test "Equivalency" {
                try reflexivity(testing_sample);
                try symmetry(testing_sample);
                try transitivity(testing_sample);
            }
        };
    };
}

/// This function generates an equality function. This equality is guaranteed to be:
/// - reflexive `∀x : equals(x, x)`
/// - symmetric `∀x, y : equals(x, y) == equals(y, x)`
/// - transitive `∀x, y, z : (equals(x, y) and equals(y, z)) => equals(x, z)`
/// It will be meaningful in most contexts, but if what you need is not an equality function, but a
/// way to check for special equivalent cases, you should implement it yourself.
pub fn equalsFn(comptime T: type) fn (T, T) bool {
    return struct {
        fn anyEquals(a: anytype, b: @TypeOf(a)) bool {
            const A = @TypeOf(a);
            const info = @typeInfo(A);
            return switch (info) {
                // The following types are considered numerical values.
                .Bool,
                .ComptimeFloat,
                .ComptimeInt,
                .Enum,
                .EnumLiteral,
                .ErrorSet,
                .Int,
                .Float,
                // Types are their id, which is a numerical value.
                .Type,
                => a == b,
                // The following are single-value types, therefore they allays equals themselves.
                .Void, .Null, .Undefined => true,
                // Error unions, optionals, and unions are all sum types. Two sum type instances
                // are equals when they have the same tag and payload.
                .ErrorUnion => if (a) |yes_a| {
                    return if (b) |yes_b| anyEquals(yes_a, yes_b) else |_| false;
                } else |no_a| {
                    return if (b) |_| false else |no_b| no_a == no_b;
                },
                .Optional => if (a) |some_a| {
                    return if (b) |some_b| anyEquals(some_a, some_b) else false;
                } else b == null,
                .Union => |Union| if (Union.tag_type) |Tag| {
                    const variant_a = @field(Tag, @tagName(a));
                    const variant_b = @field(Tag, @tagName(b));
                    if (variant_a != variant_b) return false;
                    const unwrapped_a = @field(a, @tagName(a));
                    const unwrapped_b = @field(b, @tagName(b));
                    return anyEquals(unwrapped_a, unwrapped_b);
                } else misc.compileError(
                    "Can't implement `{s}.anyEquals` function for the untagged union `{s}`!",
                    .{ @typeName(T), @typeName(A) },
                ),
                // Structs, vectors and array are product types, two instances of them are equal if
                // all their members are equal.
                .Struct => |Struct| inline for (Struct.fields) |field| {
                    const field_a = @field(a, field.name);
                    const field_b = @field(b, field.name);
                    if (!anyEquals(field_a, field_b)) break false;
                } else true,
                .Vector, .Array => inline for (a, b) |c, d| {
                    if (!anyEquals(c, d)) break false;
                } else true,
                // Pointers are semantically meant to not hold any relevant data, but point to it.
                // So we're effectively not comparing pointers, but the data they're pointing to.
                .Pointer => |Pointer| switch (Pointer.size) {
                    .One => anyEquals(a.*, b.*),
                    // Slices can be thought as a special case of both a pointer (we're comparing
                    // the data they're pointing to), and arrays (we're comparing all their
                    // members, except they don't allways have the same number of members). In both
                    // cases this seems like the right thing to do.
                    .Slice => if (a.len != b.len) false else for (a, b) |c, d| {
                        if (!anyEquals(c, d)) break false;
                    } else true,
                    // A many pointer can emulate a slice if they have a sentinel.
                    .Many => if (Pointer.sentinel) |sentinel_ptr| {
                        var index: usize = 0;
                        const sentinel = @as(*const Pointer.child, @ptrCast(sentinel_ptr)).*;
                        return while (true) : (index += 1) {
                            if (!anyEquals(a[index], b[index])) break false;
                            if (anyEquals(a[index], sentinel)) break true;
                        } else unreachable;
                    } else misc.compileError(
                        "Can't implement `{s}.anyEquals` for type `{s}`, which is a " ++ "many-item pointer to `{s}` without a sentinel!",
                        .{ @typeName(T), @typeName(A), @typeName(Pointer.child) },
                    ),
                    // C-pointers don't carry enough information by themselves to know if they're
                    // equals to one another.
                    .C => misc.compileError(
                        "Can't implement `{s}.anyEquals` function for type `{s}` which is a " ++
                            "c-pointer to `{s}!",
                        .{ @typeName(T), @typeName(A), @typeName(Pointer.child) },
                    ),
                },
                // The following types, idk what to do, if there's anything to do.
                .AnyFrame, .Fn, .Frame, .Opaque, .NoReturn => misc.compileError(
                    "Can't implement `{s}.anyEquals` function for type `{s}` which is a `.{s}`!",
                    .{ @typeName(T), @typeName(A), @tagName(info) },
                ),
            };
        }

        pub fn equals(a: T, b: T) bool {
            return anyEquals(a, b);
        }
    }.equals;
}

pub const PartialOrder = enum {
    none,
    forwards,
    equals,
    backwards,

    pub usingnamespace Equivalent(PartialOrder, .{});
};

/// # WithPartialOrder
///
/// TODO
///
/// ## API
/// usingnamespace Equivalent(Contractor, clauses),
/// compare: fn (self: Self, other: Self) PartialOrder,
/// le: fn (self: Self, other: Self) PartialOrder,
/// lt: fn (self: Self, other: Self) PartialOrder,
/// ge: fn (self: Self, other: Self) PartialOrder,
/// gt: fn (self: Self, other: Self) PartialOrder,
///
/// ## Clauses
pub fn WithPartialOrder(comptime Contractor: type, comptime clauses: anytype) type {
    return struct {
        const contract = contracts.Contract(Contractor, clauses);

        pub usingnamespace WithEquivalency;

        pub const compare: fn (self: Self, other: Self) PartialOrder =
            contract.default(.compare, defaultCompare);

        pub fn le(self: Self, other: Self) bool {
            return compare(self, other).anyEq(&.{ .forwards, .equals });
        }

        pub fn lt(self: Self, other: Self) bool {
            return compare(self, other).eq(.forwards);
        }

        pub fn ge(self: Self, other: Self) bool {
            return compare(self, other).anyEq(&.{ .backwards, .equals });
        }

        pub fn gt(self: Self, other: Self) bool {
            return compare(self, other).eq(.backwards);
        }

        const defaultCompare: fn (Self, Self) PartialOrder = partialCompareFn(Self);

        fn equals(self: Self, other: Self) bool {
            return compare(self, other).eq(.equals);
        }

        fn reverseCompare(self: Self, other: Self) PartialOrder {
            return compare(other, self);
        }

        const sample: []const Self = contract.default(.sample, misc.emptySlice(Self));
        const ub_checked: bool = contract.default(.ub_checked, true);

        const Reversed = WithPartialOrder(Contractor, .{
            .compare = reverseCompare,
            .ub_checked = ub_checked,
            .sample = sample,
            .Self = Self,
        });

        const WithEquivalency = Equivalent(Contractor, .{
            .eq = equals,
            .ub_checked = ub_checked,
            .sample = sample,
            .Self = Self,
        });

        const Self: type = contract.default(.Self, Contractor);
    };
}

/// This function generates a comparison function.
pub fn partialCompareFn(comptime T: type) PartialOrder {
    return struct {
        fn productType(comptime Sum: type) noreturn {
            misc.compileError(
                "Can't implement `{s}.anyPartialCompare` function for the sum type `{s}`!",
                .{ @typeName(T), @typeName(Sum) },
            );
        }

        fn anyPartialCompare(a: anytype, b: @TypeOf(a)) PartialOrder {
            const A = @TypeOf(a);
            const info = @typeInfo(A);
            return switch (info) {
                // The following types are considered numerical values.
                .Bool => anyPartialCompare(@intFromBool(a), @intFromBool(b)),
                .Int, .Float, .ComptimeInt, .ComptimeFloat => if (a == b)
                    .equals
                else if (a < b)
                    .forwards
                else
                    .backwards,
                .Enum => anyPartialCompare(@intFromEnum(a), @intFromEnum(b)),
                .ErrorSet => anyPartialCompare(@intFromError(a), @intFromError(b)),
                // The following types are single-value, therefore always equals to themselves.
                .Void, .Null, .Undefined => .equals,
                // A sum type can compare two variants of itself.
                .Union => |Union| if (Union.tag_type) |Tag| {
                    const variant_a = @field(Tag, @tagName(a));
                    const variant_b = @field(Tag, @tagName(b));
                    // There's no obvious way (more than one is trivial) to compare two different
                    // variants.
                    if (variant_a != variant_b) return .none;
                    const unwrapped_a = @field(a, @tagName(a));
                    const unwrapped_b = @field(b, @tagName(b));
                    return anyPartialCompare(unwrapped_a, unwrapped_b);
                } else misc.compileError(
                    "Can't implement `{s}.anyPartialCompare` function for the untagged union `{s}`!",
                    .{ @typeName(T), @typeName(A) },
                ),
                // An error _union_ is the union of a value and an error. It's a sum type.
                .ErrorUnion => if (a) |yes_a| {
                    return if (b) |yes_b|
                        anyPartialCompare(yes_a, yes_b)
                    else
                        .none;
                } else |no_a| if (b) .none else |no_b| anyPartialCompare(no_a, no_b),
                // An optional is like a union of a void variant, and a variant of the optional's
                // child type. It's a sum type.
                .Optional => if (a) |yes_a| {
                    return if (b) |yes_b|
                        anyPartialCompare(yes_a, yes_b)
                    else
                        .none;
                } else if (b) |_| .none else .equals,
                .Pointer => |Pointer| switch (Pointer.size) {
                    // Pointers are semantically meant to not hold any relevant data, but point to it.
                    // So we're effectively not comparing pointers, but the data they're pointing to.
                    .One => anyPartialCompare(a.*, b.*),
                    // Pointers to many data are similar to product types.
                    .Slice, .Many, .C => productType(A),
                },
                // Product types!
                .Vector, .Struct, .Array => productType(A),
                // The following types, idk what to do, if there's anything to do.
                .Type, .AnyFrame, .Fn, .Frame, .Opaque, .NoReturn => misc.compileError(
                    "Can't implement `{s}.anyEquals` function for type `{s}` which is a `.{s}`!",
                    .{ @typeName(T), @typeName(A), @tagName(info) },
                ),
            };
        }

        pub fn call(self: T, other: T) PartialOrder {
            return anyPartialCompare(self, other);
        }
    }.call;
}
